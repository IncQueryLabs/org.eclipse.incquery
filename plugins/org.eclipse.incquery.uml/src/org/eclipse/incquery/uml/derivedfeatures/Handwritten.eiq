package org.eclipse.incquery.uml.derivedfeatures

import "http://www.eclipse.org/uml2/5.0.0/UML"

/*
(Extension.allInstances()->select(ext | 
  let endTypes : Sequence(Classifier) = ext.memberEnd->collect(type.oclAsType(Classifier)) in
  endTypes->includes(self) or endTypes.allParents()->includes(self) ))
*/
@Surrogate(feature = "extension")
pattern classExtension(source: Class, target: Extension) {
	Extension.memberEnd(target, memberEnd);
	Property.type(memberEnd, endType);
	Classifier(endType);
	find typeOrAllParents(endType, source);
}

private pattern typeOrAllParents(endType: Classifier, source: Class) {
	endType == source;
} or {
	find classifierAllParents(endType, source);
}

/*
(self.general()->select(oclIsKindOf(Class))->collect(oclAsType(Class))->asSet())
*/
@Surrogate(feature = "superClass")
pattern classSuperClass(source: Class, target: Class) {
	find classifierGeneral(source, target);
}

/*
(parents()->union(parents()->collect(allParents())->asSet()))
*/
pattern classifierAllParents(source: Classifier, target: Classifier) {
	find classifierParents+(source, target);
}

/*
(parents())
*/
@Surrogate(feature = "general")
pattern classifierGeneral(source: Classifier, target: Classifier) {
	find classifierParents(source, target);
}

// connectorEndDefiningEnd: ordered

/*
(ownedAttribute->select(oclIsKindOf(Port))->collect(oclAsType(Port))->asOrderedSet())
*/
// WARNING: ordering is not preserved
@Surrogate(feature = "ownedPort")
pattern encapsulatedClassifierOwnedPort(source: EncapsulatedClassifier, target: Port) {
	EncapsulatedClassifier.ownedAttribute(source, target);
}

/*
(metaclassEnd().type.oclAsType(Class))
*/
@Surrogate(feature = "metaclass")
pattern extensionMetaclass(source: Extension, target: Class) {
	find extensionMetaclassEnd(source, metaclassEnd);
	Property.type(metaclassEnd, target);
}

/*
(memberEnd->reject(p | ownedEnd->includes(p.oclAsType(ExtensionEnd)))->any(true))
*/
pattern extensionMetaclassEnd(source: Extension, target: Property) {
	Extension.memberEnd(source, target);
	neg find extensionOwnedEnd(source, target);
}

private pattern extensionOwnedEnd(source: Extension, target: ExtensionEnd) {
	Extension.ownedEnd(source, target);
}

/*
(if self.name <> null and self.allNamespaces()->select( ns | ns.name=null )->isEmpty()
then 
    self.allNamespaces()->iterate( ns : Namespace; agg: String = self.name | ns.name.concat(self.separator()).concat(agg))
else
   null
endif)
*/
@Surrogate(feature = "qualifiedName")
pattern namedElementQualifiedName(namedElement: NamedElement, qualifiedName) {
	neg find namedElementNamespace(namedElement, _);
	NamedElement.name(namedElement, qualifiedName);
} or {
	find namedElementNamespace(namedElement, namespace);
	NamedElement.name(namedElement, name);
	find namedElementQualifiedName(namespace, namespaceQualifiedName);
	qualifiedName == eval(namespaceQualifiedName + "::" + name); // XXX is separator always this?
}

pattern namedElementNamespace(namedElement: NamedElement, namespace: Namespace) {
	NamedElement.namespace(namedElement, namespace);
}

/*
(self.importMembers(elementImport.importedElement->asSet()->union(packageImport.importedPackage->collect(p | p.visibleMembers()))->asSet()))
*/
@Surrogate(feature = "importedMember")
pattern namespaceImportedMember(namespace: Namespace, importedMember: NamedElement) {
	Namespace.elementImport(namespace, elementImport);
	ElementImport.importedElement(elementImport, importedMember);
} or {
	Namespace.packageImport(namespace, packageImport);
	PackageImport.importedPackage(packageImport, importedPackage);
	find packageVisibleMember(importedPackage, importedMember);
}

/*
(if behavior = null then
	null
else
	behavior.ownedParameter->first()
endif)
*/
@Surrogate(feature = "result")
pattern opaqueExpressionResult(source: OpaqueExpression, target: Parameter) {
	OpaqueExpression.behavior.ownedParameter(source, target); // XXX only first?
}

/*
(member->select( m | m.oclIsKindOf(PackageableElement) and self.makesVisible(m))->collect(oclAsType(PackageableElement))->asSet())
*/
pattern packageVisibleMember(package_: Package, visibleMember: PackageableElement) {
	find packageDirectlyVisibleMember(package_, visibleMember);
} or {
	find packageAllImportedPackages(package_, importedPackage);
	find packageDirectlyVisibleMember(importedPackage, visibleMember);
}

private pattern packageDirectlyVisibleMember(package_: Package, directlyVisibleMember: PackageableElement) {
	Namespace.ownedMember(package_, directlyVisibleMember);
	NamedElement.visibility(directlyVisibleMember, ::public);
} or {
	Package.elementImport(package_, elementImport);
	ElementImport.visibility(elementImport, ::public);
	ElementImport.importedElement(elementImport, directlyVisibleMember);
}

private pattern packageAllImportedPackages(package_: Package, importedPackage: Package) {
	find packageImportedPackage+(package_, importedPackage);
}

private pattern packageImportedPackage(package_: Package, importedPackage: Package) {
	Namespace.packageImport(package_, packageImport);
	PackageImport.visibility(packageImport, ::public);
	PackageImport.importedPackage(packageImport, importedPackage);
}

/*
(if extendedSignature->isEmpty() then Set{} else extendedSignature.parameter->asSet() endif)
*/
@Surrogate(feature = "inheritedParameter")
pattern redefinableTemplateSignatureInheritedParameter(source: RedefinableTemplateSignature, target: TemplateParameter) {
	RedefinableTemplateSignature.extendedSignature.parameter(source, target);
}

/*
(ownedAttribute->select(isComposite)->asSet())
*/
@Surrogate(feature = "part")
pattern structuredClassifierPart(structuredClassifier: StructuredClassifier, part: Property) {
	StructuredClassifier.ownedAttribute(structuredClassifier, part);
	find propertyIsComposite(part, true);
}

/*
(aggregation = AggregationKind::composite)
*/
@Surrogate(feature = "isComposite")
pattern propertyIsComposite(
	self : Property, isComposite
) {
	find propertyIsComposite_0(self);
	isComposite == true;
} or {
	neg find propertyIsComposite_0(self);
	isComposite == false;
}

private pattern propertyIsComposite_0(
	self : Property
) {
	Property.aggregation(self, aggregationKind);
	aggregationKind_0 == AggregationKind::composite;
	aggregationKind == aggregationKind_0;
}
 
/*
(region->notEmpty())
*/
@Surrogate(feature = "isComposite")
pattern stateIsComposite(
	self : State, isComposite
) {
	find stateIsComposite_0(self, _region);
	isComposite == true;
} or {
	neg find stateIsComposite_0(self, _region);
	isComposite == false;
}

/*
(region->size () > 1)
*/
@Surrogate(feature = "isOrthogonal")
pattern stateIsOrthogonal(source: State, target) {
	regionCount == count find stateIsComposite_0(source, _region);
	target == eval(regionCount > 1);
}